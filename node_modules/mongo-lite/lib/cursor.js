// Generated by CoffeeScript 1.4.0
(function() {
  var Driver, Model, NDriver, dummy, helper, name, nativeProto, proto, v, _,
    __slice = [].slice;

  _ = require('underscore');

  helper = require('./helper');

  Driver = require('./driver');

  NDriver = require('mongodb');

  Model = null;

  Driver.Cursor = (function() {

    function Cursor(collection, selector, options) {
      this.collection = collection;
      this.selector = selector != null ? selector : {};
      this.options = options != null ? options : {};
    }

    Cursor.prototype.find = function(selector, options) {
      if (selector == null) {
        selector = {};
      }
      if (options == null) {
        options = {};
      }
      selector = _.extend({}, this.selector, selector);
      options = _.extend({}, this.options, options);
      return new this.constructor(this.collection, selector, options);
    };

    Cursor.prototype.first = function() {
      var args, callback, options, selector, _i, _ref;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (!callback) {
        throw new Error("callback required!");
      }
      _ref = [args[0] || {}, args[1] || {}], selector = _ref[0], options = _ref[1];
      options = _.extend({}, options, {
        limit: 1
      });
      return this.all(selector, options, function(err, docs) {
        var doc;
        if (!err) {
          doc = docs[0] || null;
        }
        return callback(err, doc);
      });
    };

    Cursor.prototype.all = function() {
      var args, callback, fun, list, that, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (!callback) {
        throw new Error("callback required!");
      }
      if (args.length > 0) {
        return this.find.apply(this, args).all(callback);
      } else {
        list = [];
        that = this;
        fun = function(err, doc) {
          if (err) {
            return callback(err);
          }
          if (!doc) {
            return callback(err, list);
          }
          list.push(doc);
          return that.next(fun);
        };
        return this.next(fun);
      }
    };

    Cursor.prototype.each = function() {
      var msg;
      msg = "Don't use `each`, it's not implemented by intention!      In async world there's no much sence of using `each`, because there's no way      to make another async call inside of async each.      Use `first`, `all` (with `limit` and pagination) or `next` for advanced scenario.      If You still want one, it can be easilly done in about 5 lines of code, add it      by Yourself if You really want it.";
      throw new Error(msg);
    };

    Cursor.prototype.next = function(callback) {
      var _base,
        _this = this;
      if (!callback) {
        throw new Error("callback required!");
      }
      if (this.nCursor) {
        return this._next(callback);
      } else {
        if (typeof (_base = this.collection.db).log === "function") {
          _base.log({
            info: "" + this.collection.name + ".find " + (helper.inspect(this.selector)) + ", " + (helper.inspect(this.options))
          });
        }
        return this.collection.getNative(callback, function(nCollection) {
          var selector, _ref;
          selector = helper.convertSelectorId(_this.selector);
          if ((_ref = _this.nCursor) == null) {
            _this.nCursor = nCollection.find(selector, _this.options);
          }
          return _this._next(callback);
        });
      }
    };

    Cursor.prototype._next = function(callback) {
      var that,
        _this = this;
      that = this;
      return this.nCursor.nextObject(function(err, doc) {
        if (err) {
          return callback(err);
        }
        if (doc) {
          doc = helper.convertDocIdToDriver(doc);
          return callback(err, doc);
        } else {
          that.nCursor = null;
          return callback(err, null);
        }
      });
    };

    Cursor.prototype.close = function(callback) {
      if (!this.nCursor) {
        throw new Error("cursor " + (helper.inspect(this.selector)) + " already closed!");
      }
      this.nCursor.close();
      this.nCursor = null;
      return callback();
    };

    Cursor.prototype.count = function() {
      var args, callback, _base, _i,
        _this = this;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (args.length > 0) {
        return this.find.apply(this, args).count(callback);
      } else {
        if (typeof (_base = this.collection.db).log === "function") {
          _base.log({
            info: "" + this.collection.name + ".count " + (helper.inspect(this.selector))
          });
        }
        return this.collection.getNative(callback, function(nCollection) {
          var selector;
          selector = helper.convertSelectorId(_this.selector);
          return nCollection.count(selector, callback);
        });
      }
    };

    Cursor.prototype["delete"] = function() {
      var args, callback, selector, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (args.length > 0) {
        return this.find.apply(this, args)["delete"](callback);
      } else {
        selector = helper.convertSelectorId(this.selector);
        return this.collection["delete"](selector, this.options, callback);
      }
    };

    Cursor.prototype.limit = function(n) {
      return this.find({}, {
        limit: n
      });
    };

    Cursor.prototype.skip = function(n) {
      return this.find({}, {
        skip: n
      });
    };

    Cursor.prototype.sort = function(arg) {
      return this.find({}, {
        sort: arg
      });
    };

    Cursor.prototype.paginate = function() {
      var args, options, page, perPage;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 2) {
        page = args[0], perPage = args[1];
      } else {
        options = args[0] || {};
        page = helper.safeParseInt(options.page);
        perPage = helper.safeParseInt(options.perPage);
      }
      if (page == null) {
        page = 1;
      }
      if (perPage == null) {
        perPage = Driver.extendedOptions.perPage;
      }
      if (perPage > Driver.extendedOptions.maxPerPage) {
        perPage = Driver.extendedOptions.maxPerPage;
      }
      return this.skip((page - 1) * perPage).limit(perPage);
    };

    Cursor.prototype.snapshot = function() {
      return this.find({}, {
        snapshot: true
      });
    };

    Cursor.prototype.fields = function(arg) {
      return this.find({}, {
        fields: arg
      });
    };

    Cursor.prototype.tailable = function() {
      return this.find({}, {
        tailable: true
      });
    };

    Cursor.prototype.batchSize = function(arg) {
      return this.find({}, {
        batchSize: arg
      });
    };

    Cursor.prototype.fields = function(arg) {
      return this.find({}, {
        fields: arg
      });
    };

    Cursor.prototype.hint = function(arg) {
      return this.find({}, {
        hint: arg
      });
    };

    Cursor.prototype.explain = function(arg) {
      return this.find({}, {
        explain: arg
      });
    };

    Cursor.prototype.fields = function(arg) {
      return this.find({}, {
        fields: arg
      });
    };

    Cursor.prototype.timeout = function(arg) {
      return this.find({}, {
        timeout: arg
      });
    };

    Cursor.prototype.remove = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this["delete"].apply(this, args);
    };

    return Cursor;

  })();

  dummy = function() {};

  proto = Driver.Cursor.prototype;

  nativeProto = NDriver.Cursor.prototype;

  for (name in nativeProto) {
    v = nativeProto[name];
    if (!proto[name] && _.isFunction(v)) {
      (function(name) {
        return proto[name] = function() {
          var args, callback, _base;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (typeof (_base = this.db).log === "function") {
            _base.log({
              info: "" + this.collection.name + "." + name + " " + (helper.inspect(args))
            });
          }
          callback = _.isFunction(args[args.length - 1]) ? args[args.length - 1] : dummy;
          return this.getNative(callback, function(nCursor) {
            return nCursor[name].apply(nCursor, args);
          });
        };
      })(name);
    }
  }

}).call(this);
